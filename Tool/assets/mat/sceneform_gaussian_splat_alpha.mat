material {
    "name" : "Test Textured",
    "parameters" : [
        {
           "type" : "sampler2d",
           "name" : "texture"
        },
        { type : int, name : shDegree,default : 0}
    ],
    variables : [
        colorFromSh,
        test1,
        test2,
        test3
    ],
    "requires" : [
        position,
        uv0,
        custom0,  // f_dc and opacity
        custom1,  // custom1-custom6 store f_rest_0-f_rest_23 SH coeffs
        custom2,
        custom3,
        custom4,
        custom5,
        custom6
    ],
    doubleSided : true,
    shadingModel : unlit,
    blending : transparent
}

vertex {
    #include "glsl/ShCoeffsToColorFast.glsl"

    void materialVertex(inout MaterialVertexInputs material) {

        // refering to https://google.github.io/filament/Materials.html#materialdefinitions/shaderpublicapis/vertexonly,
        // the worldPosition coordinate in the vertex shader is shifted by the camera position.
        vec3 dir = material.worldPosition.xyz;
        float inorm = inversesqrt(dot(dir, dir));
        dir = dir * inorm;

        // According to "../../shader/glsl/ShCoeffsToColorFast.glsl", the coeffs should be in the following order:
        // [Y0_R, Y0_G, Y0_B, Y1m1_R, Y1m1_G, Y1m1_B, Y10_R, Y10_G, Y10_B, Y11_R, Y11_G, Y11_B, Y2m2_R, Y2m2_G, Y2m2_B, ...]
        vec3 colors;

        float4 f_dc_and_opacity = getCustom0();
        colors = sh0_coeffs_to_color_fast(f_dc_and_opacity.xyz);

        if (materialParams.shDegree >= 1) {
            float coeffs_sh1[3 * 3];
            float4 buffer1 = getCustom1();
            float4 buffer2 = getCustom2();

            for (int i = 0; i < 4; i++) {
                coeffs_sh1[i] = buffer1[i];
                coeffs_sh1[4 + i] = buffer2[i];
            }

            float4 buffer3 = getCustom3();
            coeffs_sh1[8] = buffer3[0];

            colors += sh1_coeffs_to_color_fast(dir, coeffs_sh1);
        }

        if (materialParams.shDegree >= 2) {
            float coeffs_sh2[5 * 3];

            float4 buffer3 = getCustom3();
            coeffs_sh2[0] = buffer3[1];
            coeffs_sh2[1] = buffer3[2];
            coeffs_sh2[2] = buffer3[3];

            float4 buffer4 = getCustom4();
            float4 buffer5 = getCustom5();
            float4 buffer6 = getCustom6();

            for (int i = 0; i < 4; i++) {
                coeffs_sh2[3 + i] = buffer4[i];
                coeffs_sh2[3 + 4 + i] = buffer5[i];
                coeffs_sh2[3 + 2*4 + i] = buffer6[i];
            }

            colors += sh2_coeffs_to_color_fast(dir, coeffs_sh2);
        }

        material.colorFromSh.r = colors[0];
        material.colorFromSh.g = colors[1];
        material.colorFromSh.b = colors[2];
        material.colorFromSh.a = 0.0;

        // The following code is just used for verifing we can get data from different buffer.
        //material.test1 = getCustom7();
        material.test2 = getCustom1();
        material.test3 = getCustom6();
    }
}

fragment {
    float sRGB_to_linear(float color) {
        return color <= 0.04045 ? color / 12.92 : pow((color + 0.055) / 1.055, 2.4);
    }

    float linear_to_sRGB(float color) {
        return color <= 0.0031308 ? color * 12.92 : 1.055 * pow(color, 1.0 / 2.4) - 0.055;
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);
        vec4 tex = texture(materialParams_texture, getUV0());
        vec3 shColor = variable_colorFromSh.rgb;

        // 核心混合：SH 调制纹理
        vec3 finalColor = tex.rgb * shColor;

        material.baseColor = vec4(finalColor, tex.a);
    }
}
